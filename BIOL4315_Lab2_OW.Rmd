---
title: "BIOL4315_Lab2_OW"
author: "OceanneYW"
date: "2025-09-11"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r 2.5 Quality check illumina reads, echo=TRUE}
#Load the package
library(Rqc)

#Get the path to the file
folder <- system.file(package="ShortRead", "extdata/E-MTAB-1147")

# feeds fastq.qz files in "folder" to quality check function
qcRes <- rqc(path = folder, pattern = ".fastq.gz", openBrowser=FALSE)
```

```{r 2.5.1 Sequencing Quality per Base/cycle, echo=TRUE}
rqcCycleQualityBoxPlot(qcRes)
```

```{r 2.5.2 Sequence Content Per Base/Cycle, echo=TRUE}
rqcCycleBaseCallsLinePlot(qcRes)
```

```{r 2.5.3 Read Frequency Plot, echo=TRUE}
rqcReadFrequencyPlot(qcRes)
```
```{r 2.5.4-1 Over-represented k-mers & adapter overrepresentation plots, echo=TRUE}
library(fastqcr)

# Aggregating Multiple FastQC Reports into a Data Frame 

# Demo QC directory containing zipped FASTQC reports
qc.dir <- system.file("fastqc_results", package = "fastqcr")
qc <- qc_aggregate(qc.dir)
qc
```

```{r 2.5.4-2 Inspecting QC Problems, echo=TRUE}
# See which modules failed in the most samples
qc_fails(qc, "module")

# Or, see which samples failed the most
qc_fails(qc, "sample")

# Building Multi QC Reports
qc_report(qc.dir, result.file = "multi-qc-report" )

# Building One-Sample QC Reports (+ Interpretation)
qc.file <- system.file("fastqc_results", "S1_fastqc.zip", package = "fastqcr")
```

```{r 2.5.4-3 View the report rendered by R functions, echo=TRUE}
qc_report(qc.file, result.file = "one-sample-report",
          interpret = TRUE)
```

```{r 2.2.5 QC for long reads, eval=FALSE}
conda activate sequali_env
conda install wget
wget -nc ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR153/001/ERR1539001/ERR1539001.fastq.gz
sequali --outdir /sequali_reports path/to/ERR1539001.fastq.gz
```

```{r 2.5.5.1 What to look for in a sequali output, echo=FALSE, eval=FALSE}
N50: 6681
Mean: 4888.03
Median: 4870?


```

```{r 2.6 Filtering and Trimming Short reads, eval=FALSE}
BiocManager::install("QuasR")
library(QuasR)

# obtain a list of fastq file paths
fastqFiles <- system.file(package="ShortRead",
                          "extdata/E-MTAB-1147",
                          c("ERR127302_1_subset.fastq.gz",
                            "ERR127302_2_subset.fastq.gz")
)

# defined processed fastq file names
outfiles <- paste(tempfile(pattern=c("processed_1_",
                              "processed_2_")),".fastq",sep="")

# process fastq files
# remove reads that have more than 1 N, (nBases)
# trim 3 bases from the end of the reads (truncateEndBases)
# Remove ACCCGGGA patern if it occurs at the start (Lpattern)
# remove reads shorter than 40 base-pairs (minLength)
preprocessReads(fastqFiles, outfiles, 
                nBases=1,
                truncateEndBases=3,
                Lpattern="ACCCGGGA",
                minLength=40)
```

```{r 2.6 Short reads part, eval=FALSE}
library(ShortRead)

# obtain a list of fastq file paths
fastqFile <- system.file(package="ShortRead",
                          "extdata/E-MTAB-1147",
                          "ERR127302_1_subset.fastq.gz")

# read fastq file
fq = readFastq(fastqFile)

# get quality scores per base as a matrix
qPerBase = as(quality(fq), "matrix")

# get number of bases per read that have quality score below 20
# we use this
qcount = rowSums( qPerBase <= 20) 

# Number of reads where all Phred scores >= 20
fq[which(qcount == 0)]

#We can finally write out the filtered fastq file with the ShortRead::writeFastq() function

#mode = 'a' allows you to rewrite files that are already written
ShortRead::writeFastq( fq[which(qcount == 0)], paste(getwd(), "Qfiltered3.fastq", sep="/"), mode = 'a') 

# set up streaming with block size 1000
# every time we call the yield() function 1000 read portion
# of the file will be read successively. 
f <- FastqStreamer(fastqFile,readerBlockSize=1000) 

# we set up a while loop to call yield() function to
# go through the file
while(length(fq <- yield(f))) {
  
    # remove reads where all quality scores are < 20 
    # get quality scores per base as a matrix
    qPerBase = as(quality(fq), "matrix")

    # get number of bases per read that have Q score < 20
    qcount = rowSums( qPerBase <= 20) 
 
    # write fastq file with mode="a", so every new block
    # is written out to the same file
    writeFastq(fq[which(qcount == 0)], 
               paste(fastqFile, "Qfiltered", sep="_", mode = 'a'), 
               mode="a")
}

```